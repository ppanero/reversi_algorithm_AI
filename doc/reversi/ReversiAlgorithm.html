<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_25) on Wed Sep 18 14:33:41 EEST 2013 -->
<title>ReversiAlgorithm</title>
<meta name="date" content="2013-09-18">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ReversiAlgorithm";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../reversi/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../reversi/NodeComparator.html" title="class in reversi"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?reversi/ReversiAlgorithm.html" target="_top">Frames</a></li>
<li><a href="ReversiAlgorithm.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">reversi</div>
<h2 title="Interface ReversiAlgorithm" class="title">Interface ReversiAlgorithm</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>java.lang.Runnable</dd>
</dl>
<hr>
<br>
<pre>public interface <span class="strong">ReversiAlgorithm</span>
extends java.lang.Runnable</pre>
<div class="block">The interface each reversi algorithm must implement. ReversiAlgorithm defines the
 interface between the game and the algorithm. It can be used e.g. as follows:<br>
 <pre>
  import reversi.*;
  import java.util.Vector;

  public class MyAlgorithm implements ReversiAlgorithm
  {
      // Constants
      private final static int DEPTH_LIMIT = 6; // Just an example value.

      // Variables
      boolean initialized;
      volatile boolean running; // Note: volatile for synchronization issues.
      GameController controller;
      GameState initialState;
      int myIndex;
      Move selectedMove;

      public MyAlgorithm() {} //the constructor
      
      public void requestMove(GameController requester)
      {
          running = false;
          requester.doMove(selectedMove);
      }

      public void init(GameController game, GameState state, int playerIndex, int turnLength)
      {
          initialState = state;
          myIndex = playerIndex;
          controller = game;
          initialized = true;
      }

      public String getName() { return "MyAlgorithm"; }

      public void cleanup() {}

      public void run()
      {
          //implementation of the actual algorithm
          while(!initialized);
          initialized = false;
          running = true;
          selectedMove = null;

          int currentDepth = 1;

          while (running && currentDepth < DEPTH_LIMIT)
          {
              Move newMove = searchToDepth(currentDepth++);
              
              // Check that there's a new move available.
              if (newMove != null)
                  selectedMove = newMove;
          }
      
          if (running) // Make a move if there is still time left.
          {
              controller.doMove(selectedMove);
          }
      }
      
      Move searchToDepth(int depth)
      {
          // - Create the tree of depth d (breadth first, depth first, beam search, alpha beta pruning, ...)
          // - Evaluate the leaf nodes
          // - If you think normal minimax search is enough, call the propagateScore method of the parent node
          //   of each leaf node
          // - Call the getOptimalChild method of the root node
          // - Return the move in the optimal child of the root node
          // - Don't forget the time constraint! -> Stop the algorithm when variable "running" becomes "false"
          //   or when you have reached the maximum search depth.

          Move optimalMove;
          Vector moves = initialState.getPossibleMoves(myIndex);
       
          if (moves.size() > 0)
              optimalMove = (Move)moves.elementAt(0); // Any movement that just happens to be first.
          else
              optimalMove = null;
          
          return optimalMove;
      }
  }
 </pre>
 The algorithm is controlled by a Game object, which calls the methods defined in the ReversiAlgorithm
 interface. The life cycle of an algorithm object is explained in the documentation of the Game class<p>
 Note that if the algorithm class has a constructor, also an empty (parameterless) constructor must be defined.
 It is also possible not to define a constructor at all.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../reversi/Game.html" title="class in reversi"><code>Game</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../reversi/ReversiAlgorithm.html#cleanup()">cleanup</a></strong>()</code>
<div class="block">Cleans up the algorithm.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../reversi/ReversiAlgorithm.html#getName()">getName</a></strong>()</code>
<div class="block">Returns the name of the algorithm.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../reversi/ReversiAlgorithm.html#init(reversi.GameController, reversi.GameState, int, int)">init</a></strong>(<a href="../reversi/GameController.html" title="interface in reversi">GameController</a>&nbsp;game,
    <a href="../reversi/GameState.html" title="class in reversi">GameState</a>&nbsp;initialState,
    int&nbsp;playerIndex,
    int&nbsp;turnLength)</code>
<div class="block">Initialization of the algorithm.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../reversi/ReversiAlgorithm.html#requestMove(reversi.GameController)">requestMove</a></strong>(<a href="../reversi/GameController.html" title="interface in reversi">GameController</a>&nbsp;requester)</code>
<div class="block">The game controller uses this method to inform the algorithm that it is running out of time.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Runnable">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.lang.Runnable</h3>
<code>run</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="requestMove(reversi.GameController)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>requestMove</h4>
<pre>void&nbsp;requestMove(<a href="../reversi/GameController.html" title="interface in reversi">GameController</a>&nbsp;requester)</pre>
<div class="block">The game controller uses this method to inform the algorithm that it is running out of time.
 The computed move must be sent to the controller in 300 ms after the requestMove() call
 or the algorithm will be disqualified.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>requester</code> - the game controller to which the move is sent</dd></dl>
</li>
</ul>
<a name="init(reversi.GameController, reversi.GameState, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre>void&nbsp;init(<a href="../reversi/GameController.html" title="interface in reversi">GameController</a>&nbsp;game,
        <a href="../reversi/GameState.html" title="class in reversi">GameState</a>&nbsp;initialState,
        int&nbsp;playerIndex,
        int&nbsp;turnLength)</pre>
<div class="block">Initialization of the algorithm. Before each move the game controller initializes the
 algorithm by sending it the current game state and the amount of time the algorithm can use
 for computation. In this method the algorithm should save the values. The actual computation
 is performed in the run() method which is called after the call of init() method.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>game</code> - the game controller to which the computed move is sent</dd><dd><code>initialState</code> - the game state from which to start the computation</dd><dd><code>playerIndex</code> - the player index of the algorithm (light or dark discs)</dd><dd><code>turnLength</code> - the amount of time (in seconds) the algorithm has for computation. This
                   information can be discarded, since the game controller calls the requestMove() method 
                   of the algorithm 300 ms before it runs out of time.</dd></dl>
</li>
</ul>
<a name="cleanup()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanup</h4>
<pre>void&nbsp;cleanup()</pre>
<div class="block">Cleans up the algorithm. After the game the controller calls the cleanup() method of the algorithm
 so that the algorithm can free the resources (files etc.) it has reserved. If the algorithm does
 not reserve any such resources, this method is usually empty.</div>
</li>
</ul>
<a name="getName()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getName</h4>
<pre>java.lang.String&nbsp;getName()</pre>
<div class="block">Returns the name of the algorithm.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the name of the algorithm, which is used by the game e.g. when declaring the winner.</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../reversi/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../reversi/NodeComparator.html" title="class in reversi"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?reversi/ReversiAlgorithm.html" target="_top">Frames</a></li>
<li><a href="ReversiAlgorithm.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
